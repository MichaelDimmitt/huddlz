defmodule CreateHuddlSteps do
  use Cucumber, feature: "create_huddl.feature"
  use HuddlzWeb.ConnCase, async: true

  import PhoenixTest
  import Huddlz.Generator
  alias Huddlz.Communities.Huddl
  require Ash.Query

  @tomorrow DateTime.utc_now() |> DateTime.add(1, :day)

  # Background steps - users and groups
  defstep "the following users exist:", context do
    users =
      context.datatable.maps
      |> Enum.map(fn user_data ->
        role =
          case user_data["role"] do
            "verified" -> :verified
            "regular" -> :regular
            "admin" -> :admin
            _ -> :regular
          end

        generate(
          user(
            email: user_data["email"],
            display_name: user_data["display_name"],
            role: role
          )
        )
      end)

    {:ok, Map.put(context, :users, users)}
  end

  defstep "the following groups exist:", context do
    groups =
      context.datatable.maps
      |> Enum.map(fn group_data ->
        owner_email = group_data["owner_email"]

        owner =
          Enum.find(context.users, fn u ->
            to_string(u.email) == owner_email
          end)

        is_public = group_data["is_public"] == "true"

        if owner do
          generate(
            group(
              name: group_data["name"],
              owner_id: owner.id,
              is_public: is_public,
              actor: owner
            )
          )
        else
          raise "Owner not found for email: #{owner_email}"
        end
      end)

    {:ok, Map.put(context, :groups, groups)}
  end

  defstep "the following group memberships exist:", context do
    memberships =
      context.datatable.maps
      |> Enum.map(fn membership_data ->
        user_email = membership_data["user_email"]
        group_name = membership_data["group_name"]

        role =
          case membership_data["role"] do
            "organizer" -> :organizer
            "member" -> :member
            _ -> :member
          end

        user =
          Enum.find(context.users, fn u ->
            to_string(u.email) == user_email
          end)

        group =
          Enum.find(context.groups, fn g ->
            g && to_string(g.name) == group_name
          end)

        if user && group do
          # Find the owner to act as the actor for adding members
          owner = Enum.find(context.users, &(&1.id == group.owner_id))

          generate(
            group_member(
              group_id: group.id,
              user_id: user.id,
              role: role,
              actor: owner
            )
          )
        else
          nil
        end
      end)

    {:ok, Map.put(context, :memberships, memberships)}
  end

  # Authentication step
  defstep "I am signed in as {string}", context do
    email = List.first(context.args)

    user =
      Enum.find(context.users, fn u ->
        to_string(u.email) == email
      end)

    # Sign in the user using the authentication helper
    conn = login(context.conn, user)

    # PhoenixTest uses the conn directly as the session
    {:ok, Map.merge(context, %{conn: conn, session: conn, current_user: user})}
  end

  # Navigation steps
  defstep "I visit the {string} group page", context do
    group_name = List.first(context.args)
    groups = Map.get(context, :groups, [])

    group =
      Enum.find(groups, fn g ->
        g && to_string(g.name) == group_name
      end)

    if !group do
      raise "Group not found: #{group_name}. Available groups: #{inspect(Enum.map(groups, & &1.name))}"
    end

    session = context.session |> visit("/groups/#{group.id}")

    {:ok, Map.merge(context, %{session: session, current_group: group})}
  end

  defstep "I visit the new huddl page for {string}", context do
    group_name = List.first(context.args)

    group =
      Enum.find(context.groups, fn g ->
        g && to_string(g.name) == group_name
      end)

    session = context.session |> visit("/groups/#{group.id}/huddlz/new")

    {:ok, Map.merge(context, %{session: session, current_group: group})}
  end

  defstep "I try to visit the new huddl page for {string}", context do
    group_name = List.first(context.args)

    group =
      Enum.find(context.groups, fn g ->
        g && to_string(g.name) == group_name
      end)

    # PhoenixTest handles redirects automatically
    session = context.session |> visit("/groups/#{group.id}/huddlz/new")

    # We'll check later in assertions if we were redirected
    {:ok, Map.merge(context, %{session: session, current_group: group})}
  end

  # Visibility checks
  defstep "I should see a {string} button", context do
    button_text = List.first(context.args)
    # Try to find either a link or button with the text
    try do
      assert_has(context.session, "a", text: button_text)
    rescue
      _ -> assert_has(context.session, "button", text: button_text)
    end

    :ok
  end

  defstep "I should not see a {string} button", context do
    button_text = List.first(context.args)
    refute_has(context.session, "a", text: button_text)
    refute_has(context.session, "button", text: button_text)
    :ok
  end

  defstep "I click {string}", context do
    button_text = List.first(context.args)

    # Try clicking as a link first, then as a button
    session =
      try do
        context.session |> click_link(button_text)
      rescue
        _ -> context.session |> click_button(button_text)
      end

    {:ok, Map.merge(context, %{session: session})}
  end

  defstep "I should be on the new huddl page for {string}", context do
    group_name = List.first(context.args)

    # PhoenixTest assertions
    assert_has(context.session, "h1", text: "Create New Huddl")
    assert_has(context.session, "span", text: group_name)

    {:ok, context}
  end

  # Form interaction steps
  defstep "I fill in the huddl form with:", context do
    form_data =
      context.datatable.maps
      |> Enum.reduce(%{}, fn field_data, acc ->
        field = field_data["Field"]
        value = field_data["Value"]

        case field do
          "Title" ->
            Map.put(acc, "title", value)

          "Description" ->
            Map.put(acc, "description", value)

          "Start Date & Time" ->
            start_time = parse_relative_time(value)
            # Format for HTML datetime-local input: YYYY-MM-DDTHH:MM
            formatted = Calendar.strftime(start_time, "%Y-%m-%dT%H:%M")
            Map.put(acc, "starts_at", formatted)

          "End Date & Time" ->
            end_time = parse_relative_time(value)
            # Format for HTML datetime-local input: YYYY-MM-DDTHH:MM
            formatted = Calendar.strftime(end_time, "%Y-%m-%dT%H:%M")
            Map.put(acc, "ends_at", formatted)

          "Event Type" ->
            event_type =
              case value do
                "In-Person" -> "in_person"
                "Virtual" -> "virtual"
                "Hybrid" -> "hybrid"
                _ -> "in_person"
              end

            Map.put(acc, "event_type", event_type)

          "Physical Location" ->
            Map.put(acc, "physical_location", value)

          "Virtual Link" ->
            Map.put(acc, "virtual_link", value)
        end
      end)

    {:ok, Map.put(context, :form_data, form_data)}
  end

  defstep "I submit the form", context do
    form_data = Map.get(context, :form_data, %{})

    # Fill in the form fields using PhoenixTest
    session = context.session

    session =
      Enum.reduce(form_data, session, fn {field, value}, acc_session ->
        case field do
          "title" ->
            fill_in(acc_session, "Title", with: value, exact: false)

          "description" ->
            fill_in(acc_session, "Description", with: value, exact: false)

          "starts_at" ->
            fill_in(acc_session, "Start Date & Time", with: value, exact: false)

          "ends_at" ->
            fill_in(acc_session, "End Date & Time", with: value, exact: false)

          "event_type" ->
            select(acc_session, "Event Type", option: humanize_event_type(value), exact: false)

          "physical_location" ->
            fill_in(acc_session, "Physical Location", with: value, exact: false)

          "virtual_link" ->
            fill_in(acc_session, "Virtual Meeting Link", with: value, exact: false)

          _ ->
            acc_session
        end
      end)

    # Submit the form - PhoenixTest handles redirects automatically
    session = submit(session)

    # Debug: Check if we have any validation errors
    # open_browser(session)

    {:ok, Map.merge(context, %{session: session})}
  end

  defstep "I submit the form without filling it", context do
    # PhoenixTest requires interacting with a form before submitting
    # We'll click a submit button which will trigger form submission
    session = context.session |> click_button("Create Huddl")

    {:ok, Map.merge(context, %{session: session})}
  end

  # Field visibility steps
  defstep "I should see {string} field", context do
    field_label = List.first(context.args)
    assert_has(context.session, "label", text: field_label)
    :ok
  end

  defstep "I should not see {string} field", context do
    field_label = List.first(context.args)
    refute_has(context.session, "label", text: field_label)
    :ok
  end

  defstep "I select {string} from {string}", context do
    [value, field] = context.args

    session = context.session |> select(field, option: value, exact: false)

    {:ok, Map.put(context, :session, session)}
  end

  defstep "I should not see a checkbox for {string}", context do
    label = List.first(context.args)
    refute_has(context.session, "input[type='checkbox']")
    refute_has(context.session, "label", text: label)
    :ok
  end

  defstep "I should see {string}", context do
    text = List.first(context.args)
    assert_has(context.session, "body", text: text)
    {:ok, context}
  end

  # Redirection and result steps
  defstep "I should be redirected to the {string} group page", context do
    group_name = List.first(context.args)

    group =
      Enum.find(context.groups, fn g ->
        g && to_string(g.name) == group_name
      end)

    # Check current path with PhoenixTest
    assert_path(context.session, "/groups/#{group.id}")
    {:ok, context}
  end

  defstep "the huddl should be created as private", context do
    # Wait a moment for any async operations to complete
    Process.sleep(100)

    # Find the most recently created huddl using the correct actor
    huddl =
      Huddl
      |> Ash.Query.filter(title == "Private Meeting")
      |> Ash.read_one!(actor: context.current_user, authorize?: true)

    assert huddl != nil, "Huddl 'Private Meeting' was not created"
    assert huddl.is_private == true
    :ok
  end

  defstep "I should see validation errors for required fields", context do
    # With PhoenixTest, we check that we're still on the form page
    assert_has(context.session, "h1", text: "Create New Huddl")
    assert_has(context.session, "#huddl-form")
    :ok
  end

  defstep "I should remain on the new huddl page", context do
    assert_has(context.session, "h1", text: "Create New Huddl")
    :ok
  end

  # Helper functions
  defp parse_relative_time("tomorrow at " <> time) do
    [hour_str, minute_str, period] =
      case String.split(time, ~r/[:\s]+/) do
        [h, m, p] -> [h, m, p]
        [h, p] -> [h, "00", p]
      end

    hour = String.to_integer(hour_str)
    minute = String.to_integer(minute_str)

    # Convert to 24-hour format
    hour =
      cond do
        period == "PM" and hour != 12 -> hour + 12
        period == "AM" and hour == 12 -> 0
        true -> hour
      end

    @tomorrow
    |> DateTime.add(hour, :hour)
    |> DateTime.add(minute, :minute)
  end

  defp humanize_event_type("in_person"), do: "In-Person"
  defp humanize_event_type("virtual"), do: "Virtual"
  defp humanize_event_type("hybrid"), do: "Hybrid (Both In-Person and Virtual)"
  defp humanize_event_type(type), do: type
end
